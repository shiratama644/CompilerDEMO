# Z++詳細言語仕様書 v1.0

## 目次
1. [はじめに](#1章-はじめに-introduction)
2. [字句構造](#2章-字句構造-lexical-structure)
3. [データ型、変数、定数](#3章-データ型変数定数-data-types-variables-and-constants)
4. [式と演算子](#4章-式と演算子-expressions-and-operators)
5. [演算子の優先順位](#5章-演算子の優先順位)
6. [文と制御構造](#6章-文と制御構造-statements-and-control-structures)
7. [関数](#7章-関数-functions)
8. [組み込み機能](#8章-組み込み機能-built-in-features)
9. [名前空間とモジュール](#9章-名前空間とモジュール-namespaces-and-modules)

---

## 1章 はじめに (Introduction)

### 1.1. Z++とは
Z++は、本ドキュメントで規定される**8ビットCPU向けに設計された、C++ライクな静的型付け高級プログラミング言語**です。C++の強力な表現力と抽象化能力を継承しつつ、リソースが限られた8ビット環境でも効率的に動作するよう、仕様が最適化されています。

Z++で記述されたソースコードの拡張子は **`.zpp`** とします。

### 1.2. 設計思想
Z++は、以下の3つの原則を重視して設計されています。

- **透明性 (Transparency):** Z++のコードが、最終的にどのようなアセンブリコードに変換されるかを予測しやすくします。これにより、開発者はパフォーマンスクリティカルな部分を意識したコーディングが可能です。
- **効率性 (Efficiency):** 生成されるコードは、ターゲットCPUのアーキテクチャを最大限に活用し、メモリ使用量と実行速度の両面で高い効率を目指します。
- **表現力 (Expressiveness):** 低レベルな記述を極力避け、ハードウェアの機能を抽象化された直感的な構文（特にI/O操作）で記述できるようにします。

---

## 2章 字句構造 (Lexical Structure)

### 2.1. コメント (Comments)
ソースコード内に記述できる、プログラムの動作に影響を与えない注釈です。

#### 単一行コメント
`//` から行末までがコメントになります。
```zpp
int led_pin = 3; // LEDを接続するピン番号
```

#### 複数行コメント
`/*` と `*/` で囲まれた範囲がコメントになります。
```zpp
/*
    このブロックは複数行にわたる
    コメントのサンプルです。
*/
```

### 2.2. 識別子 (Identifiers)
変数名、関数名、型名などに使用される名前です。

- **命名規則:** 英字 (`a-z`, `A-Z`) またはアンダースコア (`_`) で始まり、2文字目以降は英数字とアンダースコアが使用できます。
- **大文字・小文字の区別:** 区別されます。`myValue` と `myvalue` は異なる識別子です。
- **例:** `counter`, `_status`, `ADC_Read_Value`

### 2.3. キーワード (Keywords)
言語の文法上、特別な意味を持つ予約語です。識別子として使用することはできません。

```
int void const if else while do for return switch case default break 
Output Input Run struct class public private sizeof
```

### 2.4. リテラル (Literals)
ソースコードに直接記述される値です。

- **10進数リテラル:** `123`
- **16進数リテラル:** `0xFF` (接頭辞 `0x` を使用)
- **2進数リテラル:** `0b10101010` (接頭辞 `0b` を使用)

---

## 3章 データ型、変数、定数 (Data Types, Variables, and Constants)

### 3.1. データ型
Z++で利用可能な基本的なデータ型は以下の通りです。

| 型名 | 説明 | サイズ | 値の範囲 |
|------|------|--------|----------|
| `int` | 符号なし整数型 | 8ビット | 0 から 255 |
| `void` | 値が存在しないことを示す特殊な型 | - | - |
| `enum` | 関連する定数群をまとめた独自の型 | 8ビット | 詳細は3.7章参照 |
| `struct` | 複数の変数をまとめた複合データ型 | メンバの合計 | 詳細は3.4章参照 |
| `class` | データとメソッドをまとめた複合データ型 | メンバの合計 | 詳細は3.5章参照 |
| 配列 | 同じ型のデータを連続格納するデータ構造 | 要素数×要素サイズ | 詳細は3.6章参照 |

### 3.2. 変数 (Variables)
値を格納するための名前付きメモリ領域です。

#### 宣言と初期化
```zpp
int life;        // 宣言のみ
int score = 100; // 宣言と同時に初期化
```

#### スコープ (有効範囲)
- **ブロックスコープ:** `{}` で囲まれたブロック内で宣言された変数は、そのブロック内でのみ有効
- **グローバルスコープ:** いずれのブロックにも属さずに宣言された変数は、プログラム全体からアクセス可能

### 3.3. 定数 (`const`)
一度値を代入すると変更できなくなる変数です。

#### 特徴
- **目的:** 変更されては困る値（ピン番号、設定値など）を安全に扱う
- **メモリ配置:** **ROM領域**に配置されるため、**RAMを消費しません**
- **宣言:** `const int 定数名 = 値;`
- **制約:** コンパイル時に値が確定している必要がある

#### アセンブリレベルの動作
`const` で宣言された定数は、アセンブラの `.define` ディレクティブに変換され、コード中のシンボルが即値に置換されます。

#### 使用例
```zpp
const int LED_PIN = 3;
const int SENSOR_PORT = 2;
Output(255, LED_PIN); // ポート3のLEDを最大輝度で点灯
```

### 3.4. 構造体 (struct) - データ集約のための型

`struct` は、複数の異なる型の変数を一つのまとまりとして扱うための機能です。

#### 3.4.1. 構造体とクラスの基本的な違い
`struct` と `class` の唯一の違いは、**デフォルトのアクセス指定子**です。

- **`struct` のデフォルトは public:** データ集約を主目的とし、外部から自由にアクセスできることを前提
- **`class` のデフォルトは private:** カプセル化を主目的とし、内部状態を隠蔽することを前提

#### 3.4.2. 機能的な共通点
`struct` と `class` は、アクセス指定子 (`public`, `private`) を明示的に記述すれば、機能的に全く同じものとして扱えます。

#### 3.4.3. 構造体の機能
`struct` は `class` と同様に以下の機能を持つことができます：

- **メンバ変数:** 構造体が保持するデータ
- **メンバ関数 (メソッド):** 構造体のデータを操作する関数
- **コンストラクタ:** インスタンス生成時に自動的に呼び出される初期化用の特殊な関数

#### 3.4.4. 使用例

```zpp
// 2次元座標を表す 'Point' 構造体
struct Point {
    // デフォルトで public:
    int x;
    int y;

    // デフォルトコンストラクタ (原点(0, 0)で初期化)
    Point() {
        x = 0;
        y = 0;
    }

    // 座標を移動させるメンバ関数
    void move(int dx, int dy) {
        x += dx;
        y += dy;
    }

    // 原点からの距離の2乗を返すメンバ関数
    int distance_sq_from_origin() {
        int x_sq_low = x * x;
        int y_sq_low = y * y;
        return x_sq_low + y_sq_low;
    }
};

// 使用例
int main() {
    struct Point p1;  // デフォルトコンストラクタが呼ばれる
    
    p1.x = 10;        // メンバは public なので直接アクセス可能
    p1.y = 20;
    
    p1.move(-5, 10);  // p1 は (5, 30) になる
    
    int dist_sq = p1.distance_sq_from_origin();
    
    return 0;
}
```

### 3.5. クラス (class) - カプセル化のための型

`class` は、データ（メンバ変数）と、そのデータを操作するための一連の手続き（メンバ関数）を一つにまとめたものです。

#### 3.5.1. なぜ `struct` だけでなく `class` が必要なのか
`struct` は主にデータの集約に用いられます。`class` は**カプセル化**を強制する仕組みを提供し、データの整合性を保ちやすくします。

#### 3.5.2. アクセス指定子 `public`/`private`

| アクセス指定子 | 説明 |
|----------------|------|
| `public` | クラスの外部からアクセス可能。クラスのインターフェースを構成 |
| `private` | そのクラスのメンバ関数からのみアクセス可能。内部状態を隠蔽 |

#### 3.5.3. メンバ関数の定義
- **クラス内定義:** 簡単な関数は、`class` の定義ブロック内に直接実装を記述
- **クラス外定義:** 実装が長い場合は、クラス内で宣言のみ行い、実装をクラス外に記述。**スコープ解決演算子 `::`** を使用

#### 3.5.4. コンストラクタ (Constructor)
インスタンスが生成される際に**自動的に呼び出される**特殊なメンバ関数です。

- **目的:** メンバ変数の初期化
- **名前:** クラス名と同じ名前を持ち、戻り値の型はなし
- **特徴:** 引数を取ることができ、複数のコンストラクタを定義可能（オーバーロード）

#### 3.5.5. 暗黙の引数 `this`
メンバ関数は、どのインスタンスの変数を操作すればよいかを区別するために、**`this`ポインタ**を使用します。

- **アセンブリレベル:** Z++の呼び出し規約では、`this`ポインタは**`r1`レジスタ**に格納
- **後続の引数:** `r2`, `r3`... と順にレジスタに割り当て

#### 3.5.6. サポートされないC++の機能
8ビットCPUでの効率的な実装を優先するため、以下の機能はサポートしません：

- 継承
- 仮想関数 (Virtual Functions)
- デストラクタ (Destructor)

#### 3.5.7. クラスの使用例

```zpp
// タイマークラスの定義
class Timer {
public:
    Timer();                          // コンストラクタ
    void set_limit(int new_limit);
    void tick();
    int has_expired();

private:
    int counter;
    int limit;
    int is_expired;
};

// メンバ関数の実装 (クラス外定義)
Timer::Timer() {
    counter = 0;
    limit = 255;
    is_expired = 0;
}

void Timer::set_limit(int new_limit) {
    limit = new_limit;
}

void Timer::tick() {
    counter = counter + 1;
    if (counter >= limit) {
        is_expired = 1;
        counter = 0;
    }
}

int Timer::has_expired() {
    if (is_expired == 1) {
        is_expired = 0;
        return 1;
    }
    return 0;
}

// 使用例
int main() {
    class Timer short_timer;
    class Timer long_timer;

    short_timer.set_limit(100);
    long_timer.set_limit(200);

    for (int i = 0; i < 255; i++) {
        short_timer.tick();
        long_timer.tick();

        if (short_timer.has_expired()) {
            Output(1, 0);  // ポート0のLEDを点灯
        }

        if (long_timer.has_expired()) {
            Output(1, 1);  // ポート1のLEDを点灯
        }
    }

    return 0;
}
```

### 3.6. 配列 (array)

同じデータ型の要素を、連続したメモリ領域に複数格納するためのデータ構造です。

#### 宣言と初期化
```zpp
int scores[10];                    // int型の要素を10個持つ配列
struct Point path[5];              // struct Point型の要素を5個持つ配列

int pins[4] = {2, 3, 4, 5};       // 初期値を指定
int data[5] = {10, 20};           // {10, 20, 0, 0, 0} として初期化
```

#### 要素へのアクセス
```zpp
scores[0] = 100;                  // 最初の要素に値を代入
int first_score = scores[0];      // 最初の要素の値を取得
```

> **注意:** 範囲外アクセスのチェックは行われないため、プログラマが注意する必要があります。

#### 多次元配列
```zpp
int matrix[3][4];                 // 3行4列の2次元配列
matrix[1][2] = 1;                 // 2行目3列目の要素にアクセス
```

#### `sizeof` 演算子
```zpp
int scores[10];
int total_size = sizeof(scores);  // 10 が返る (sizeof(int) * 10)
```

#### 関数への引き渡し
配列を関数に渡す際は、**先頭要素へのアドレス（ポインタ）**が渡されます。

```zpp
void process_data(int arr[]);
process_data(&scores);            // 配列の先頭アドレスを渡す
```

### 3.7. 列挙型 (enum) - 型安全な定数グループ

`enum`（列挙型）は、関連する定数群を一つのグループとしてまとめ、それに**独自の新しい「型」を与える**機能です。

#### 3.7.1. `enum`の必要性
`const int RED = 0;` のような定数の集まりでは、互いの関連性がなく、`int`型の変数には無関係な値も代入できてしまいます。`enum`は、コンパイラに厳格なルールを理解させ、不正な値の代入をコンパイル時に検出できるようにします。

#### 3.7.2. `enum`の定義と使い方

```zpp
// 信号機の状態を表す、'TrafficSignal'という新しい型を定義
enum TrafficSignal {
    RED,      // 自動的に 0 が割り当てられる
    YELLOW,   // 自動的に 1 が割り当てられる
    BLUE      // 自動的に 2 が割り当てられる
};

// 使用方法
enum TrafficSignal current_signal;
current_signal = TrafficSignal::RED;

if (current_signal == TrafficSignal::YELLOW) {
    // 黄信号の場合の処理
}
```

#### 3.7.3. `enum`の利点

- **型安全性 (Type Safety):** `enum`型の変数には、その`enum`で定義された列挙子しか代入できない
- **可読性 (Readability):** `case TrafficSignal::RED:` は `case 0:` より意図が明確
- **ゼロコスト抽象化:** コンパイル時に解決され、実行時のパフォーマンスペナルティなし

#### 3.7.4. 基底となる整数値の指定

```zpp
enum DeviceCommand {
    RESET = 0,
    START = 1,
    SET_SPEED = 0x10,     // 16進数で16を指定
    GET_STATUS = 0x20
};
```

#### 3.7.5. 型変換の規則

| 変換の種類 | 例 | 許可 | 結果の型 | 備考 |
|------------|----|----- |----------|------|
| `enum` → `int` | `int i = LedState::ON;` | **OK (暗黙的)** | `int` | 常に安全 |
| `int` → `enum` | `LedState s = 1;` | **エラー** | - | 型安全性を保証 |
| `int` → `enum` (キャスト) | `LedState s = (LedState)1;` | **OK (明示的)** | `enum LedState` | プログラマの責任 |
| `enum` → `enum` | `LedState s = PowerState::ON;` | **エラー** | - | 型が異なる |
| `enum`との演算 | `int i = LedState::ON + 1;` | **OK** | `int` | `enum`は`int`に変換されてから計算 |

---

## 4章 式と演算子 (Expressions and Operators)

### 4.1. 算術演算子

| 演算子 | 説明 | CPU命令対応 | 備考 |
|--------|------|-------------|------|
| `+` | 加算 | ADD | オーバーフローでラップアラウンド |
| `-` | 減算 | SUB | |
| `*` | 乗算（下位） | MUL | 8ビット結果の下位8ビット |
| `**` | 乗算（上位） | MUH | 8ビット結果の上位8ビット |
| `/` | 除算 | DIV | 商（整数部） |
| `%` | 剰余 | MOD | 余り |
| `++` | インクリメント | - | 前置・後置両対応 |
| `--` | デクリメント | - | 前置・後置両対応 |
| `+=`, `-=`, `*=`, `**=`, `/=`, `%=` | 複合代入演算子 | - | |

#### 乗算の例
```zpp
int a = 10;
int b = 3;
int product_low = a * b;   // product_low は 30
int product_high = a ** b; // product_high は 0
int quotient = a / b;      // quotient は 3
int remainder = a % b;     // remainder は 1
```

### 4.2. 比較演算子

| 演算子 | 説明 |
|--------|------|
| `==` | 等しい |
| `!=` | 等しくない |
| `<` | 小なり |
| `>` | 大なり |
| `<=` | 小なりイコール |
| `>=` | 大なりイコール |

### 4.3. 論理演算子

| 演算子 | 説明 | 特徴 |
|--------|------|------|
| `&&` | 論理AND | 短絡評価をサポート |
| `||` | 論理OR | 短絡評価をサポート |

### 4.4. ビット単位演算子

| 演算子 | 説明 | CPU命令対応 |
|--------|------|-------------|
| `&` | ビットAND | AND |
| `|` | ビットOR | - |
| `^` | ビットXOR | XOR |
| `~` | ビットNOT | NOR（`r0`との組み合わせ） |
| `<<` | 左シフト | LSH |
| `>>` | 右シフト | RSH |

### 4.5. その他の演算子

| 演算子 | 説明 | 使用例 |
|--------|------|--------|
| `&` | アドレス演算子 | `&variable` |
| `.` | メンバアクセス | `p.x` |
| `->` | ポインタ経由メンバアクセス | `ptr->x` |
| `::` | スコープ解決 | `Class::member` |
| `sizeof` | サイズ取得 | `sizeof(int)` |
| `[]` | 配列アクセス | `arr[0]` |

---

## 5章 演算子の優先順位

優先順位が高いものほど先に評価されます。

| 優先順位 | 演算子 | 結合方向 | 説明 |
|----------|--------|----------|------|
| 1 (最高) | `()`, `[]`, `.`, `->` | 左→右 | 関数呼び出し、配列添字、メンバアクセス |
| 2 | `++`, `--` (後置) | 左→右 | 後置インクリメント・デクリメント |
| 3 | `**` | 左→右 | 乗算（上位） |
| 4 | `++`, `--`, `~`, `&`, `sizeof` (単項) | **右→左** | 単項演算子 |
| 5 | `*`, `/`, `%` | 左→右 | 乗除算 |
| 6 | `+`, `-` | 左→右 | 加減算 |
| 7 | `<<`, `>>` | 左→右 | ビットシフト |
| 8 | `<`, `>`, `<=`, `>=` | 左→右 | 関係演算子 |
| 9 | `==`, `!=` | 左→右 | 等価演算子 |
| 10 | `&` | 左→右 | ビットAND |
| 11 | `^` | 左→右 | ビットXOR |
| 12 | `|` | 左→右 | ビットOR |
| 13 | `&&` | 左→右 | 論理AND |
| 14 | `||` | 左→右 | 論理OR |
| 15 (最低) | `=`, `+=`, `-=`, `*=`, `**=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=` | **右→左** | 代入演算子 |

---

## 6章 文と制御構造 (Statements and Control Structures)

### 6.1. if - else if - else 文

条件に基づいて実行フローを分岐させる基本的な制御構造です。

#### 動作原理
1. `if (condition)` の条件式が評価される
2. 条件が真（0でない）なら `if` ブロックを実行
3. 偽（0）なら次の `else if` の条件式を評価
4. 全ての条件が偽なら `else` ブロックを実行（存在する場合）

#### 使用例
```zpp
// 温度に応じてファンを制御する例
if (temperature > 100) {
    // 危険な状態。ファンを最大でONにする
    Output(255, FAN_PORT);
} else if (temperature > 60) {
    // 注意が必要な状態。ファンを中速で回す
    Output(128, FAN_PORT);
} else {
    // 正常な状態。ファンを停止する
    Output(0, FAN_PORT);
}
```

### 6.2. while ループ

指定された条件が真である間、繰り返し処理を実行する制御構造です。

#### 動作原理
1. ループに入る前に条件式を評価
2. 条件が真なら、ループ内のブロックを実行
3. ブロック完了後、再び条件式を評価
4. 条件が偽になるまで繰り返し

#### 使用例
```zpp
// ポート2のボタンが押されるまで待機する
int button_state;
cin(2) >> button_state >> end;
while (button_state == 0) {
    cin(2) >> button_state >> end;
}
// ボタンが押された後の処理
```

### 6.3. do-while ループ

最初に必ず一度ブロック内の処理を実行してから、条件式を評価する制御構造です。

#### 使用例
```zpp
// センサーの初期化処理
int sensor_status;
do {
    // センサーからステータスを読み込む
    cin(SENSOR_PORT) >> sensor_status >> end;
} while (sensor_status != 1);
```

### 6.4. for ループ

カウンタ変数を使った繰り返し処理を簡潔に記述する制御構造です。

#### 書式
```zpp
for (初期化式; 条件式; 後処理式) {
    // ループ処理
}
```

#### 動作原理
1. **初期化式:** ループ開始前に一度だけ実行
2. **条件式:** ループ実行前に毎回評価
3. **ループ本体:** 条件が真の間実行
4. **後処理式:** ループ本体実行後に毎回実行

#### 使用例
```zpp
// ポート1のLEDを0から255まで徐々に明るくする
for (int brightness = 0; brightness <= 255; brightness++) {
    Output(brightness, 1);
}
```

### 6.5. switch 文

一つの変数の値に応じて、複数の分岐先から一つを選択する多方向分岐の制御構造です。

#### 動作原理
1. `switch (expression)` の式を評価
2. `case constant:` の定数と値を比較
3. 一致する `case` から処理開始
4. `break` 文まで連続実行（フォールスルー）
5. どの `case` にも一致しない場合は `default` を実行

#### アセンブリレベルの最適化
コンパイラは効率的な実装のため、**ジャンプテーブル**を利用する場合があります。これにより、複数の比較分岐よりも高速な処理が可能です。

#### 使用例
```zpp
enum OperationMode { STANDBY, RUNNING, ERROR_STATE };
enum OperationMode current_mode = STANDBY;

switch (current_mode) {
    case OperationMode::STANDBY:
        // スタンバイモードの処理
        break;
    case OperationMode::RUNNING:
        // 実行モードの処理
        break;
    case OperationMode::ERROR_STATE:
    default:
        // エラーまたは未定義状態の処理
        break;
}
```

### 6.6. break 文

最も近い外側のループ（`while`, `do-while`, `for`）または `switch` 文を強制終了し、その直後の文に制御を移します。

#### 使用例
```zpp
int input_value;
while (1) { // 無限ループ
    cin(0) >> input_value >> end;
    if (input_value == 100) {
        break; // ループを抜ける
    }
}
// ループ終了後の処理
```

### 6.7. return 文

現在の関数の実行を終了し、呼び出し元に制御を戻します。

#### 形式
- `return;` - `void`型関数で使用
- `return expression;` - 戻り値を持つ関数で使用

#### アセンブリレベルの動作
- 戻り値は呼び出し規約で定められた`r15`レジスタに格納
- `RET`命令で呼び出し元に復帰
- 関数内で変更したレジスタ（`r5`〜`r14`）の復元が必要

#### 使用例
```zpp
// 2つのintを加算して返す関数
int add(int a, int b) {
    return a + b; // 結果をr15に格納してRET命令で復帰
}

int main() {
    int result = add(10, 20);
    return 0;
}
```

---

## 7章 関数 (Functions)

### 7.1. 関数の定義と呼び出し

一連の処理をまとめて名前を付け、再利用できるようにした機能です。

#### 基本例
```zpp
// 2つのintを加算して返す関数
int add(int a, int b) {
    return a + b;
}

// 関数の呼び出し
int result = add(10, 20); // result に 30 が代入される
```

#### 7.1.1. デフォルト引数

関数の宣言時に、引数にデフォルト値を指定できます。

##### 宣言と使用
```zpp
void set_led(int pin, int brightness = 255);

// 呼び出し例
set_led(3);       // pin=3, brightness=255 で呼び出される
set_led(3, 128);  // pin=3, brightness=128 で呼び出される
```

##### 制約
- デフォルト引数は引数リストの**右側**にまとめる必要がある
- `void func(int a = 10, int b);` のような宣言はエラー

##### アセンブリレベルの動作
コンパイラが省略された引数を補って関数呼び出しコードを生成します。

### 7.2. 呼び出し規約 (Calling Convention)

関数を呼び出す側と呼び出される側での、引数や戻り値の受け渡しに関するルールです。

#### 引数の渡し方

##### 値渡し (デフォルト)
`int`, `struct`, `class` などの引数は、**値がコピーされて**渡されます。関数内で引数の値を変更しても、呼び出し元の変数は影響を受けません。

##### 参照渡し (`&`)
型名の後に `&` を付けると、変数の**メモリアドレス（8ビット）**が渡されます。関数内での変更は呼び出し元の変数に直接反映されます。

```zpp
// 値渡し: p1のコピーが渡される
void draw_point(struct Point pt);
draw_point(p1);

// 参照渡し: p1のアドレスが渡される
void move_point(struct Point& pt);
move_point(p1);
```

##### 配列の引き渡し (特殊ケース)
- 配列は**常に先頭要素へのアドレスが渡される**
- 関数定義では `int arr[]` と記述（`int* arr` と等価）
- 呼び出し時には配列名の前に `&` を明示的に付ける

```zpp
void process_scores(int arr[]); // 配列を受け取る関数の宣言

int my_scores[50];
process_scores(&my_scores); // 配列の先頭アドレスを渡す
```

#### レジスタ割り当て

##### 引数レジスタ
`int`型の引数（および参照渡しの`&`）は以下の順でレジスタに割り当て：

| 引数 | レジスタ | 備考 |
|------|----------|------|
| 第1引数 | `r1` | クラスのメンバ関数では`this`ポインタが使用 |
| 第2引数 | `r2` | |
| 第3引数 | `r3` | |
| 第4引数 | `r4` | |

##### スタック渡し
- 引数が5個以上の場合
- `int`以外の大きな型（値渡しの`struct`や`class`）の場合
- 呼び出し側が確保したRAM上の領域（スタックフレーム）経由で受け渡し

#### 戻り値の扱い
- `int`型の戻り値: `r15`レジスタに格納して返す
- 大きな型（`struct`や`class`）: 戻り値用領域のアドレスを引数として渡す

#### レジスタの退避ルール

| 分類 | レジスタ | 責任 | 説明 |
|------|----------|------|------|
| **Caller-Saved** | `r1-r4`, `r15` | 呼び出し側 | 必要に応じて呼び出し側が退避 |
| **Callee-Saved** | `r5-r14` | 呼び出される側 | 使用する場合は関数が退避・復元 |

---

## 8章 組み込み機能 (Built-in Features)

### 8.1. ストリーム形式I/O (`cout`, `cin`)

#### 出力ストリーム (`cout`)
```zpp
cout(port) << value1 << value2 << ... << end;
```

- `port`: 出力ポート番号を指定する`int`型の式
- `<<`: `int`型の値や変数を出力キューに追加
- `end`: キューの内容を実際のポートに出力

#### 入力ストリーム (`cin`)
```zpp
cin(port) >> var1 >> var2 >> ... >> end;
```

- `port`: 入力ポート番号を指定する`int`型の式
- `>>`: ポートから読み取った値を**参照渡し**で変数に格納
- `end`: 実際のポート読み込みを実行

#### 使用例
```zpp
int sensor_val;
const int LED_PORT = 3;

// ポート2から値を1つ読み込み、sensor_valに格納
cin(2) >> sensor_val >> end;

// LED_PORT(ポート3)に sensor_val の値と 255 を連続して出力
cout(LED_PORT) << sensor_val << 255 << end;
```

### 8.2. インラインアセンブリ

Z++コード内に直接アセンブリコードを埋め込む機能です。

#### 単一行アセンブリ
```zpp
Run.Asm("アセンブリ命令");
```

#### 複数行アセンブリブロック
```zpp
Run.AsmBlock {
    // 複数行のアセンブリコードを記述
}
```

> **注意:** Z++の変数やレジスタ割り当てを破壊しないよう、CPUの仕様を熟知した上で使用する必要があります。

### 8.3. デバッグ出力 (`Run.Debug`)

プログラムの実行を妨げることなく、開発中のデバッグ情報をホストPC（IDE）に送信する機能です。

#### 書式
```zpp
Run.Debug("フォーマット文字列", expression1, expression2, ...);
```

#### 動作の仕組み

##### コンパイル時 (`.zpp` → `.asm`)
Z++コンパイラは、`Run.Debug`文を**何のアセンブリコードにも変換せず、完全に無視**します。これにより、製品版のコードサイズや実行速度に一切影響を与えません。

##### デバッグ実行時 (IDEの役割)
IDEはソースコードを解析し、`Run.Debug`文が記述された行に到達すると、`expression`の部分を評価し、その値をフォーマット文字列の`{}`に埋め込んでデバッグコンソールに表示します。

#### 重要な注意点
- この機能は**デバッグビルド時にのみ有効**
- 実際のデバイスで実行されるバイナリには含まれない
- `expression`部分に**副作用のある式**（`i++`など）を記述しても、実行時には無視される

#### 使用例
```zpp
struct Point p;
p.x = 50;
p.y = 100;

// IDEのデバッグコンソールに "Player position: (50, 100)" と表示
Run.Debug("Player position: ({}, {})", p.x, p.y);

// IDEのデバッグコンソールに "Initialization complete." と表示
Run.Debug("Initialization complete.");
```

---

## 9章 名前空間とモジュール (Namespaces and Modules)

Z++は、コードの再利用性を高め、大規模なプロジェクトを整理して管理するための強力なモジュールシステムを提供します。

### 9.1. Z++におけるモジュールの考え方

プログラムが大きくなるにつれて、全てのコードを一つのファイルに記述するのは非効率的になり、名前の衝突のリスクも増大します。

Z++のモジュールシステムは以下の方法でこの問題を解決します：

1. 関連する機能を意味のある単位の**ファイル（モジュール）**に分割
2. **`namespace`**を使って、モジュール内の機能を論理的なグループに分け、名前の衝突を防止
3. **`#include`**と**`using`**を使って、必要な機能だけを安全にインポートして利用

### 9.2. プリプロセッサ命令

プリプロセッサ命令は、コンパイラが本格的なコード解析を始める前に実行される、テキストベースの処理です。`#`で始まります。

#### 9.2.1. インクルードガード (`#ifndef`, `#define`, `#endif`)

`#include`が単純なテキスト展開であるため、同じファイルが複数回インクルードされると、同じ関数やクラスが二重に定義されてしまいます。これを防ぐため、再利用を目的としたファイルは、**必ずインクルードガードで囲む**必要があります。

```zpp
// my_module.zpp
#ifndef MY_MODULE_ZPP  // 'MY_MODULE_ZPP'が未定義なら...
#define MY_MODULE_ZPP  // 'MY_MODULE_ZPP'を定義済みにする

// --- ここにモジュールの内容を記述 ---
namespace MyModule {
    // ...
}

#endif // MY_MODULE_ZPP の終わり
```

これにより、このファイルがプログラム全体で何回`#include`されても、その内容は最初の1回しかコンパイル対象になりません。

#### 9.2.2. ファイルのインクルード (`#include`)

指定されたファイルの内容を、その場にテキストとして挿入します。

```zpp
#include "ファイルパス"
```

### 9.3. 名前空間 (`namespace`)

`namespace`は、プログラム内の識別子が所属する「空間」を定義し、名前の衝突を防ぎます。

#### 9.3.1. 名前空間の定義

```zpp
// my_utils.zpp
namespace Math {
    int add(int a, int b) { return a + b; }
}

namespace IO {
    void print(int val);
}
```

#### 9.3.2. グローバル名前空間

`namespace`ブロックの外側で定義されたシンボルは、**グローバル名前空間**に所属します。これは、全ての名前空間の親となる暗黙的な空間です。

#### 9.3.3. 無名名前空間によるアクセス制御

名前を指定せずに定義された名前空間（無名名前空間）の中のシンボルは、**そのファイルの外側からは完全にアクセス不可能**になります。

```zpp
namespace {
    // このファイル内部でのみ使用可能
    int internal_helper() { return 42; }
}
```

### 9.4. シンボルのインポートとアクセス

`#include`したファイル内のシンボルを利用するには、以下の3つの方法があります。

#### 9.4.1. スコープ解決演算子 (`::`)

`名前空間::シンボル名`の形式で、どの名前空間に属するシンボルかを明示的に指定します。

```zpp
#include "my_math.zpp"

int result = Math::add(10, 20); // Math名前空間のaddを呼び出す
```

グローバル名前空間のシンボルを明示的に指定する場合は`::シンボル名`と記述します。

#### 9.4.2. `using`宣言 (特定シンボルのインポート)

特定のシンボルだけを現在のスコープに持ち込み、接頭辞なしで使えるようにします。**推奨されるインポート方法**です。

##### 書式
```zpp
using 名前空間::シンボル名;
using シンボル名;  // グローバル名前空間からのインポート
```

##### 使用例
```zpp
#include "my_math.zpp"
#include "global_utils.zpp"

using Math::add;        // Math名前空間のaddだけをインポート
using global_func;      // グローバル名前空間のglobal_funcをインポート

int result = add(5, 3); // OK: Math::addのこと
global_func();          // OK: ::global_funcのこと
```

#### 9.4.3. `using namespace`宣言 (名前空間全体のインポート)

指定した名前空間に含まれる**全てのシンボル**を現在のスコープに持ち込みます。便利ですが、意図しない名前の衝突を引き起こす可能性があるため注意が必要です。

```zpp
#include "my_math.zpp"
using namespace Math; // Math名前空間の全てを使用可能にする

int result = add(5, 3); // OK
```

### 9.5. 名前の衝突と曖昧さの解決

異なる名前空間から同じ名前のシンボルを`using`でインポートした場合、その名前をそのまま使おうとすると**コンパイルエラー**となります。

#### 曖昧な呼び出し（エラーになる例）
```zpp
#include "file_a.zpp"  // ::calculate を含む
#include "file_b.zpp"  // Math::calculate を含む

using calculate;
using Math::calculate;

int result = calculate(10); // エラー！どちらを指すか曖昧
```

#### 曖昧さの解決
スコープ解決演算子`::`を使い、どちらのバージョンを呼び出すかを明示的に指定します。

```zpp
int result1 = ::calculate(10);      // グローバル名前空間のバージョン
int result2 = Math::calculate(10);  // Math名前空間のバージョン
```

### 9.6. 総合的な使用例

#### ライブラリファイル (`my_library.zpp`)
```zpp
#ifndef MY_LIBRARY_ZPP
#define MY_LIBRARY_ZPP

// 非公開な内部実装（このファイル内からのみアクセス可能）
namespace {
    int internal_state = 0;
    void update_state() { internal_state++; }
}

// 公開インターフェース
namespace MyLib {
    void run() {
        update_state();
    }
    const int VERSION = 1;
}

// グローバルな便利関数
void global_utility() { /* ... */ }

#endif
```

#### アプリケーションファイル (`main.zpp`)
```zpp
#include "my_library.zpp"

// MyLib名前空間から'run'関数をインポート
using MyLib::run;
// グローバル名前空間から'global_utility'をインポート
using global_utility;

int main() {
    // OK: 'run'はインポートされている
    run();

    // OK: 'global_utility'もインポートされている
    global_utility();

    // OK: 'VERSION'はフルネームでアクセス可能
    if (MyLib::VERSION == 1) {
        // ...
    }

    // コンパイルエラー！
    // 'internal_state'は無名名前空間内のためアクセス不可
    // int state = internal_state;

    return 0;
}
```

### 9.7. デッドコード除去とROM効率

Z++コンパイラは、最終的なプログラムのROMサイズを最小限に抑えるため、**デッドコード除去**の最適化を実装します。

#### 動作原理
1. `#include`でファイルの内容をテキスト挿入（第一段階）
2. `main`関数を起点として、実際に呼び出される可能性のある全ての関数を連鎖的に解析（生存コード分析）
3. 「生存している」と判断された関数のみを最終的なアセンブリコードとして生成
4. 「死んでいる」コードは完全に破棄され、ROM領域を消費しない

#### 例

**ライブラリファイル (`my_math.zpp`)**
```zpp
namespace Math {
    int add(int a, int b) { return a + b; }
    
    // この関数はmainからは呼び出されない
    int sub(int a, int b) { return a - b; }
}
```

**メインファイル (`main.zpp`)**
```zpp
#include "my_math.zpp"
using namespace Math;

int main() {
    // add関数のみが呼び出される
    return add(10, 5);
}
```

この場合、コンパイラは：
- `Math::add`関数を「生存している」と判断 → アセンブリコード生成
- `Math::sub`関数を「死んでいる」と判断 → ROM領域を消費しない

これにより、大きなライブラリをインクルードしても、実際に使用しない機能がROM効率に影響することはありません。

---

## 付録

### A. キーワード一覧
```
int void const if else while do for return switch case default break 
Output Input Run struct class public private sizeof using namespace
```

### B. 演算子一覧
```
+ - * ** / % ++ -- += -= *= **= /= %= 
== != < > <= >= && || & | ^ ~ << >> 
= &= |= ^= <<= >>= . -> :: [] () sizeof
```

### C. CPU命令との対応表

| Z++演算子 | CPU命令 | 説明 |
|-----------|---------|------|
| `+` | ADD | 加算 |
| `-` | SUB | 減算 |
| `*` | MUL | 乗算（下位） |
| `**` | MUH | 乗算（上位） |
| `/` | DIV | 除算 |
| `%` | MOD | 剰余 |
| `&` | AND | ビットAND |
| `^` | XOR | ビットXOR |
| `~` | NOR | ビットNOR（r0との組み合わせ） |
| `<<` | LSH | 左シフト |
| `>>` | RSH | 右シフト |
