### 第1部：CPUアーキテクチャ仕様

#### 1.1. 基本アーキテクチャ
*   **CPU種別:** 8ビット・ロードストアアーキテクチャ
*   **パイプライン:** 高スループットを実現する**10段パイプライン**。
    *   **ステージ構成:** `IF1`, `IF2`, `ID`, `RR`, `EX`, `MA1`, `MA2`, `MA3`, `WB`, `PCU`
*   **クロック:** すべての動作はクロック単位で同期して進みます。

#### 1.2. ハザード対策と特別仕様
*   **制御ハザード対策:**
    *   **分岐予測:** `BRH`命令に対し、**「常に分岐しない (Not Taken)」**と予測します。
    *   **投機的実行:** 分岐予測に基づき、パイプラインを停止させずに後続命令の実行を開始します。
    *   **レジスタデリート (予測失敗時の回復処理):**
        1.  分岐予測が失敗した場合に**のみ**発動します。
        2.  投機的に実行してしまった命令の結果の書き込み先レジスタ(`Rd`)をハードウェアレベルで強制的に**`r0`（ゼロレジスタ）に差し替えます。**
        3.  その後、パイプラインをフラッシュし、正しい分岐先アドレスから命令フェッチを再開します。
*   **データハザード対策:**
    *   後続命令が先行する命令の結果を必要とする場合、結果が確定するまでパイプラインを自動的に**ストール（一時停止）**させます。

#### 1.3. ハードウェア仕様
*   **レジスタセット:**
    *   **汎用レジスタ (GPR):** `r0` ～ `r15` の16個（各8ビット）。`r0`は常に`0x00`を返す**ゼロレジスタ**です。
    *   **アドレスポインタ (AP):** `ap0` ～ `ap15` の16個（各8ビット）。`ap0`は常にアドレス`0x00`を指す**ゼロポインタ**です。
*   **メモリ空間:**
    *   **ROM (命令用):** 2KiB (1024ワード × 16ビット/ワード)、10ビットアドレス。
    *   **RAM (データ用):** 256バイト、8ビットアドレス。
    *   **I/O ポート:** 入力/出力
    各16個（各8ビット）、4ビットアドレス。
    *   **Input バッファ:** Inputバッファは非同期に更新があるたびにインプットしバッファに格納していく。これにより、割り込み処理系の命令やアーキテクチャを構成する必要がなくなる。合計16Byte。
*   **ハードウェアスタック (CPU内蔵):**
    *   **コールスタック (CALstack):** 64段。`CAL`/`RET`命令で使用。
    *   **汎用スタック (GPRstack):** 64段。`PSH`/`POP`命令で使用。
*   **ALUフラグ:** `Zero(Z)`, `Not Zero(NZ)`, `Carry(C)`, `Not Carry(NC)`。

---

### 第2部：アセンブリ言語仕様

#### 2.1. 基本文法
*   **行の構造:** `[ラベル:] [ディレクティブ / 命令] [オペランド] [コメント]`
*   **区切り文字:** 各要素は1つ以上の半角スペースまたはタブで区切ります。
*   **大文字/小文字:** 命令、レジスタ名、条件コード、ディレクティブは区別しません。

#### 2.2. コメント
*   **単一行コメント:** 指定記号から行末までがコメントとなります。
    *   **書式:** `; text`, `// text`, `# text`, `## text`
*   **複数行コメント:** 開始記号と終了記号で囲まれた範囲がコメントとなります。
    *   **書式:** `/* text */`, `#* text *#`

#### 2.3. ラベル
*   **定義:** 命令のアドレスに名前を付けます。行頭から始まりコロン`:`で終わります。
*   **命名規則:** 英字で開始し、英数字とアンダースコア`_`が使用可能。予約語やシンボル名との重複は不可。

#### 2.4. アセンブラディレクティブ
アセンブラの動作を制御するための指示子。ドット`.`で始まる。

##### **.define** (シンボル定数の定義)
*   **目的:** 数値に分かりやすい名前（シンボル）を付け、コードの可読性と保守性を向上させます。
*   **書式:** `.define SYMBOL = value` または `.define SYMBOL, value`
*   **説明:** アセンブル時に、コード中の`SYMBOL`がすべて対応する`value`に置換されます。

#### 2.5. オペランドの種類と書式
*   **汎用レジスタ (GPR):** `r0` ～ `r15`
*   **アドレスポインタ (AP):** `ap0` ～ `ap15`
*   **即値 (imm):** 数値を直接記述します。
    *   **10進数:** `123`
    *   **16進数:** `0xFF`
    *   **2進数:** `0b1010`
*   **アドレス (addr):** 制御フロー命令 (`JMP`, `BRH`, `CAL`) の飛び先を指定します。
    *   **ラベル指定:** 定義済みのラベル名を記述します。（例: `MAIN_LOOP`）
    *   **絶対アドレス指定:** ROM上のアドレスを数値で直接指定することも可能です。10進数、16進数、2進数形式に対応しています。
*   **オフセット (offset):** 0～15の範囲の即値。
*   **条件コード (cond):** `BRH`命令で使用します。
    *   **ニーモニック形式:** `Z`, `NZ`, `C`, `NC`
    *   **式形式:** `==`, `!=` (または `=!`), `>=`, `<`
*   **シンボル (Symbol):** `.define`で定義された名前。

---

### 第3部：命令セットリファレンス (ISA)

このセクションでは、CPUが実行できるすべての命令について、その目的と実践的な使い方を詳述します。

#### 3.1. 算術演算命令

##### **ADD** (Addition)
*   **書式:** `ADD rA, rB, rC`
*   **動作:** `rC <- rA + rB`
*   **フラグ更新:** Yes
*   **説明:** ソースレジスタ `rA` と `rB` の値を加算し、結果をデスティネーションレジスタ `rC` に格納します。

##### **SUB** (Subtraction)
*   **書式:** `SUB rA, rB, rC`
*   **動作:** `rC <- rA - rB`
*   **フラグ更新:** Yes
*   **説明:** ソースレジスタ `rA` から `rB` の値を減算し、結果を `rC` に格納します。

##### **MUL** (Multiply Low)
*   **書式:** `MUL rA, rB, rC`
*   **動作:** `rC <- 下位8ビット(rA * rB)`
*   **フラグ更新:** Yes
*   **説明:** 8ビットレジスタ `rA` と `rB` の乗算を行い、16ビットで得られる結果の下位8ビットを `rC` に格納します。

##### **MUH** (Multiply High)
*   **書式:** `MUH rA, rB, rC`
*   **動作:** `rC <- 上位8ビット(rA * rB)`
*   **フラグ更新:** Yes
*   **説明:** 8ビットレジスタ `rA` と `rB` の乗算を行い、16ビットで得られる結果の上位8ビットを `rC` に格納します。`MUL`と組み合わせることで16ビットの乗算結果を扱えます。

##### **DIV** (Divide)
*   **書式:** `DIV rA, rB, rC`
*   **動作:** `rC <- 商(rA / rB)`
*   **フラグ更新:** Yes
*   **説明:** レジスタ `rA` を `rB` で除算した結果の商（整数部）を `rC` に格納します。

##### **MOD** (Modulo)
*   **書式:** `MOD rA, rB, rC`
*   **動作:** `rC <- 剰余(rA % rB)`
*   **フラグ更新:** Yes
*   **説明:** レジスタ `rA` を `rB` で除算した結果の剰余を `rC` に格納します。

#### 3.2. 論理演算命令

##### **NOR** (Bitwise NOR)
*   **書式:** `NOR rA, rB, rC`
*   **動作:** `rC <- !(rA | rB)`
*   **フラグ更新:** Yes
*   **説明:** ビット単位の論理和の否定。`r0`と組み合わせることで`NOT`命令として機能します (`NOR rA, r0, rC`)。

##### **AND** (Bitwise AND)
*   **書式:** `AND rA, rB, rC`
*   **動作:** `rC <- rA & rB`
*   **フラグ更新:** Yes
*   **説明:** ビット単位の論理積。特定のビットを`0`にする「ビットマスキング」に多用されます。

##### **XOR** (Bitwise eXclusive OR)
*   **書式:** `XOR rA, rB, rC`
*   **動作:** `rC <- rA ^ rB`
*   **フラグ更新:** Yes
*   **説明:** ビット単位の排他的論理和。レジスタのクリア (`XOR r1, r1, r1`) や、特定のビットの反転（トグル）に利用できます。

#### 3.3. シフト・ローテート命令

##### **LSH** (Logical Shift Left)
*   **書式:** `LSH rA, rB, rC`
*   **動作:** `rC <- rA << rB`
*   **フラグ更新:** No
*   **説明:** `rA`の値を、`rB`の値で指定されたビット数だけ左に論理シフトし、結果を `rC` に格納します。

##### **RSH** (Logical Shift Right)
*   **書式:** `RSH rA, rB, rC`
*   **動作:** `rC <- rA >> rB`
*   **フラグ更新:** No
*   **説明:** `rA`の値を、`rB`の値で指定されたビット数だけ右に論理シフトし、結果を `rC` に格納します。

##### **LRO** (Rotate Left)
*   **書式:** `LRO rA, rB, rC`
*   **動作:** `rC <- rA を rB ビット左に循環シフト`
*   **フラグ更新:** No
*   **説明:** `rA`の値を、`rB`で指定されたビット数だけ左に循環（ローテート）させ、結果を `rC` に格納します。最上位ビットからあふれたビットは最下位ビットに設定されます。

##### **RRO** (Rotate Right)
*   **書式:** `RRO rA, rB, rC`
*   **動作:** `rC <- rA を rB ビット右に循環シフト`
*   **フラグ更新:** No
*   **説明:** `rA`の値を、`rB`で指定されたビット数だけ右に循環（ローテート）させ、結果を `rC` に格納します。最下位ビットからあふれたビットは最上位ビットに設定されます。

#### 3.4. 即値命令

##### **LDI** (Load Immediate)
*   **書式:** `LDI rA, imm`
*   **動作:** `rA <- imm`
*   **フラグ更新:** No
*   **説明:** レジスタ `rA` に8ビットの即値 `imm` をロードします。

##### **RCL** (Register)
*   **書式:** `RCL`
*   **動作:** `rALL <- 0`
*   **フラグ更新:** No
*   **説明:** レジスタの全てを0にリセットします。
*   
##### **ADI** (Add Immediate)
*   **書式:** `ADI rA, imm`
*   **動作:** `rA <- rA + imm`
*   **フラグ更新:** Yes
*   **説明:** レジスタ `rA` の値に即値 `imm` を加算し、結果を元のレジスタ `rA` に書き戻します。

##### **SBI** (Subtract Immediate)
*   **書式:** `SBI rA, imm`
*   **動作:** `rA <- rA - imm`
*   **フラグ更新:** Yes
*   **説明:** レジスタ `rA` の値から即値 `imm` を減算し、結果を元のレジスタ `rA` に書き戻します。

##### **ANI** (AND Immediate)
*   **書式:** `AMI rA, imm`
*   **動作:** `rA <- rA & imm`
*   **フラグ更新:** Yes
*   **説明:** レジスタ `rA` の値と即値 `imm` でビット単位の論理積をとり、結果を元のレジスタ `rA` に書き戻します。ビットマスク処理に便利です。

#### 3.5. データ転送命令

##### **MOV** (Move)
*   **書式:** `MOV rA, rB`
*   **動作:** `rB <- rA`
*   **フラグ更新:** No
*   **説明:** ソースレジスタ `rA` の値をデスティネーションレジスタ `rB` にコピーします。アドレスポインタレジスタとレジスタ同士も可能です`(MOV r1, ap1; MOV ap1, ap2)`。

##### **SWP** (Swap)
*   **書式:** `SWP rA, rB`
*   **動作:** `rA <-> rB`
*   **フラグ更新:** No
*   **説明:** レジスタ `rA` と `rB` の値を互いに入れ替えます。一時レジスタが不要なため効率的です。アドレスポインタレジスタとレジスタ同士も可能です`(SWP r1, ap1; SWP ap1, ap2)`。

#### 3.6. 比較命令

##### **CMP** (Compare)
*   **書式:** `CMP rA(apA), rB(apB)`
*   **動作:** `rA(apA) - rB(apB)` (結果は破棄)
*   **フラグ更新:** Yes
*   **説明:** レジスタ `rA(apA)` と `rB(apB)` を比較します。演算結果は破棄されますが、ALUフラグが更新されるため、直後の`BRH`命令による条件分岐に利用されます。

##### **CMI** (Compare Immediate)
*   **書式:** `CMI rA(apA), imm`
*   **動作:** `rA(apA) - imm` (結果は破棄)
*   **フラグ更新:** Yes
*   **説明:** レジスタ `rA(apA)` と即値 `imm` を比較します。定数との比較を効率的に行うための命令です。

#### 3.7. 制御フロー命令

##### **JMP** (Jump)
*   **書式:** `JMP addr`
*   **動作:** `PC <- addr`
*   **フラグ更新:** No
*   **説明:** 無条件に指定されたアドレス`addr`にジャンプします。

##### **BRH** (Branch)
*   **書式:** `BRH cond, addr`
*   **動作:** `PC <- Cond ? addr : PC+1`
*   **フラグ更新:** No
*   **説明:** 条件`cond`が満たされた場合のみ、アドレス`addr`へジャンプします。

##### **CAL** (Call)
*   **書式:** `CAL addr`
*   **動作:** `CALstack <- PC+1; PC <- addr`
*   **フラグ更新:** No
*   **説明:** 戻りアドレスをコールスタックに退避し、サブルーチンを呼び出します。

##### **RET** (Return)
*   **書式:** `RET`
*   **動作:** `PC <- pop(CALstack)`
*   **フラグ更新:** No
*   **説明:** コールスタックから戻りアドレスを取り出し、サブルーチンから復帰します。

#### 3.8. スタック操作命令

##### **PSH** (Push)
*   **書式:** `PSH rA(apA, FLAG)`
*   **動作:** `GPRstack <- rA(apA, FLAG)`
*   **フラグ更新:** No
*   **説明:** 汎用スタックにレジスタ`rA(apA, FLAG)`の値を退避します。サブルーチン内で使用するレジスタの保存に利用します。ALUのFLAGレジスタをプッシュできます。それにより、割り込み時にフラグを書き換えられてももとに戻すことができます。

##### **POP** (Pop)
*   **書式:** `POP rA(apA, FLAG)`
*   **動作:** `rA(apA, FLAG) <- pop(GPRstack)`
*   **フラグ更新:** No
*   **説明:** 汎用スタックから値を取り出し、レジスタ`rA(apA, FLAG)`に格納します。ALUのFLAGレジスタにポップできます。それにより、割り込み時にフラグを書き換えられてももとに戻すことができます。

#### 3.9. メモリ・I/Oアクセス命令

##### **MST** (Memory Store)
*   **書式:** `MST rA, apB, offset`
*   **動作:** `Mem[apB + offset] <- rA`
*   **フラグ更新:** No
*   **説明:** レジスタ `rA` の値を、アドレスポインタ `apB` と `offset` で指定されるRAMアドレスに1バイト書き込みます。

##### **MLD** (Memory Load)
*   **書式:** `MLD rA, apB, offset`
*   **動作:** `rA <- Mem[apB + offset]`
*   **フラグ更新:** No
*   **説明:** アドレスポインタ `apB` と `offset` で指定されるRAMアドレスから1バイト読み出し、レジスタ `rA` に格納します。

##### **MCL** (Memory Clear)
*   **書式:** `MCL`
*   **動作:** `Mem[ALL] <- 0`
*   **フラグ更新:** No
*   **説明:** RAMのすべてを0にリセットします。

##### **PST** (Port Store)
*   **書式:** `PST rA, apB, offset`
*   **動作:** `O-Port[apB + offset] <- rA`
*   **フラグ更新:** No
*   **説明:** レジスタ `rA` の値を、アドレスポインタ `apB` と `offset` で指定される出力ポートに1バイト書き込みます。

##### **PLD** (Port Load)
*   **書式:** `PLD rA, apB, offset`
*   **動作:** `rA <- I-Port[apB + offset]`
*   **フラグ更新:** No
*   **説明:** アドレスポインタ `apB` と `offset` で指定される入力ポートから1バイト読み出し、レジスタ `rA` に格納します。

#### 3.10. アドレスポインタ命令

##### **API** (Address Pointer set Immediate)
*   **書式:** `API apA, imm`
*   **動作:** `apA <- imm`
*   **フラグ更新:** No
*   **説明:** アドレスポインタ `apA` に即値 `imm` を直接設定します。

##### **APD** (Address Pointer Add)
*   **書式:** `APD rA, rB, apC`
*   **動作:** `apC <- rA + rB`
*   **フラグ更新:** No
*   **説明:** レジスタ `rA` と `rB` の値を加算し、結果をアドレスポインタ `apC` に格納します。ポインタの動的な計算に用います。

##### **APS** (Address Pointer Subtract)
*   **書式:** `APS rA, rB, apC`
*   **動作:** `apC <- rA - rB`
*   **フラグ更新:** No
*   **説明:** レジスタ `rA` の値から `rB` の値を減算し、結果をアドレスポインタ `apC` に格納します。

##### **ACL** (Address Pointer Clear)
*   **書式:** `ACL`
*   **動作:** `apALL <- 0`
*   **フラグ更新:** No
*   **説明:** アドレスポインタのすべてを0にリセットします。

#### 3.11. その他の命令

##### **NOP** (No Operation)
*   **書式:** `NOP`
*   **動作:** 何もしない。
*   **フラグ更新:** No
*   **説明:** 1クロックサイクルを消費します。タイミング調整などに使用します。

##### **HLT** (Halt)
*   **書式:** `HLT`
*   **動作:** CPUの動作を停止させる。
*   **フラグ更新:** No
*   **説明:** プログラムの終端点に配置し、CPUを停止状態にします。