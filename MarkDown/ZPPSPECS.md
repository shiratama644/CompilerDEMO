## Z++詳細言語仕様書

### 1章 はじめに (Introduction)

#### 1.1. Z++とは
Z++は、本ドキュメントで規定される**8ビットCPU向けに設計された、C++ライクな静的型付け高級プログラミング言語**です。C++の強力な表現力と抽象化能力を継承しつつ、リソースが限られた8ビット環境でも効率的に動作するよう、仕様が最適化されています。

Z++で記述されたソースコードの拡張子は **`.zpp`** とします。

#### 1.2. 設計思想
Z++は、以下の3つの原則を重視して設計されています。

*   **透明性 (Transparency):** Z++のコードが、最終的にどのようなアセンブリコードに変換されるかを予測しやすくします。これにより、開発者はパフォーマンスクリティカルな部分を意識したコーディングが可能です。
*   **効率性 (Efficiency):** 生成されるコードは、ターゲットCPUのアーキテクチャを最大限に活用し、メモリ使用量と実行速度の両面で高い効率を目指します。
*   **表現力 (Expressiveness):** 低レベルな記述を極力避け、ハードウェアの機能を抽象化された直感的な構文（特にI/O操作）で記述できるようにします。

### 2章 字句構造 (Lexical Structure)

#### 2.1. コメント (Comments)
ソースコード内に記述できる、プログラムの動作に影響を与えない注釈です。

*   **単一行コメント:** `//` から行末までがコメントになります。
    ```zpp
    int led_pin = 3; // LEDを接続するピン番号
    ```
*   **複数行コメント:** `/*` と `*/` で囲まれた範囲がコメントになります。
    ```zpp
    /*
        このブロックは複数行にわたる
        コメントのサンプルです。
    */
    ```

#### 2.2. 識別子 (Identifiers)
変数名、関数名、型名などに使用される名前です。

*   **命名規則:** 英字 (`a-z`, `A-Z`) またはアンダースコア (`_`) で始まり、2文字目以降は英数字とアンダースコアが使用できます。
*   **大文字・小文字の区別:** 区別されます。`myValue` と `myvalue` は異なる識別子です。
*   **例:** `counter`, `_status`, `ADC_Read_Value`

#### 2.3. キーワード (Keywords)
言語の文法上、特別な意味を持つ予約語です。識別子として使用することはできません。
`int`, `void`, `const`, `if`, `else`, `while`, `do`, `for`, `return`, `switch`, `case`, `default`, `break`, `Output`, `Input`, `Run`, `struct`, `class`, `public`, `private`, `sizeof`

#### 2.4. リテラル (Literals)
ソースコードに直接記述される値です。

*   **10進数リテラル:** `123`
*   **16進数リテラル:** `0xFF` (接頭辞 `0x` を使用)
*   **2進数リテラル:** `0b10101010` (接頭辞 `0b` を使用)

### 3章 データ型、変数、定数 (Data Types, Variables, and Constants)

#### 3.1. データ型
Z++で利用可能な基本的なデータ型は以下の通りです。

*   **`int` :** 符号なし整数型。サイズは**8ビット**で、値の範囲は **`0` から `255`** です。
*   **`void` :** 値が存在しないことを示す特殊な型です。関数の戻り値がない場合などに使用します。
*   **`struct` :** 複数の変数をまとめたユーザー定義の複合データ型です。詳細は3.4章を参照。
*   **`class` :** データとそれを操作するメソッドをまとめた、カプセル化を目的とした複合データ型です。詳細は3.5章を参照。
*   **配列 :** 同じ型のデータを連続したメモリ領域に格納するデータ構造です。詳細は3.6章を参照。

#### 3.2. 変数 (Variables)
値を格納するための名前付きメモリ領域です。

*   **宣言:** `int 変数名;` のように、型名に続けて識別子を記述します。
*   **初期化:** 宣言と同時に値を代入できます。 `int life = 3;`
*   **スコープ (有効範囲):**
    *   **ブロックスコープ:** `{}` で囲まれたブロック内で宣言された変数は、そのブロック内でのみ有効です。
    *   **グローバルスコープ:** いずれのブロックにも属さずに宣言された変数は、プログラム全体からアクセス可能です。

#### 3.3. 定数 (`const`)
一度値を代入すると変更できなくなる変数です。

*   **目的:** 変更されては困る値（ピン番号、設定値など）を安全に扱うために使用します。**ROM領域**に配置されるため、**RAMを消費しません**。
*   **宣言:** `const int 定数名 = 値;` のように、変数の宣言の前に `const` を付けます。
*   **特徴:** コンパイル時に値が確定している必要があります。
*   **アセンブリレベルの動作:** `const` で宣言された定数は、アセンブラの `.define` ディレクティブに変換され、コード中のシンボルが即値に置換されます。
*  `const`は、グローバルスコープまたはブロックスコープで`int`型の定数を宣言するために使用できます。現行バージョンでは、`struct`/`class`のメンバ変数や、関数の引数を`const`として宣言することはサポートされていません。
*   **使用例:**
    ```zpp
    const int LED_PIN = 3;
    const int SENSOR_PORT = 2;
    Output(255, LED_PIN); // ポート3のLEDを最大輝度で点灯
    ```

#### 3.4. 構造体 (struct) - データ集約のための型

`struct` は、複数の異なる型の変数を一つのまとまりとして扱うための機能です。Z++では、`struct` と `class` は機能的に非常に似ていますが、デフォルトのアクセスレベルに違いがあります。

##### 3.4.1. 構造体とクラスの基本的な違い
`struct` と `class` の唯一の違いは、**デフォルトのアクセス指定子**です。

*   **`struct` のデフォルトは public**
    `struct` のメンバは、アクセス指定子を省略した場合、**デフォルトで `public`** になります。これは、**データ集約**を主目的とし、外部から自由にアクセスできることを前提としているためです。

*   **`class` のデフォルトは private**
    `class` のメンバは、アクセス指定子を省略した場合、**デフォルトで `private`** になります。これは、**カプセル化**を主目的とし、内部状態を隠蔽することを前提としているためです。

##### 3.4.2. `class` との機能的な共通点
Z++において、`struct` と `class` は **アクセス指定子 (`public`, `private`) を明示的に記述すれば、機能的に全く同じ**ものとして扱えます。

*   **`struct`:** デフォルトでメンバが **`public`** になります。
    ```zpp
    struct Point {
        int x; // 明示的な指定がないため public
    };
    ```
    これは `struct Point { public: int x; };` と等価です。

*   **`class`:** デフォルトでメンバが **`private`** になります。
    ```zpp
    class Player {
        int hp; // 明示的な指定がないため private
    };
    ```
    これは `class Player { private: int hp; };` と等価です。

したがって、慣習的にデータコンテナとして使われる `struct` で `private:` を使ったり、カプセル化を目的とする `class` で `public:` を使うことも文法的には可能です。

##### 3.4.3. 構造体の機能
`struct` は `class` と同様に以下の機能を持つことができます。

*   **メンバ変数:** 構造体が保持するデータ。
*   **メンバ関数 (メソッド):** 構造体のデータを操作する関数。`class` と同様に、インスタンスへのポインタ `this` が暗黙的に `r1` レジスタに渡されます。
*   **コンストラクタ:** インスタンス生成時に自動的に呼び出される初期化用の特殊な関数。`struct` でもコンストラクタを定義できます。

##### 3.4.4. サイズと `sizeof`
`struct` のサイズは、そのメンバ変数のサイズの合計になります。`sizeof` 演算子でインスタンスや型のメモリサイズ（バイト単位）を取得できます。

##### 3.4.5. 構造体の使用例
以下は、2次元座標を表す `Point` 構造体の例です。メンバはすべて `public` です。

```zpp
// 2次元座標を表す 'Point' 構造体
struct Point {
    // デフォルトで public:
    int x;
    int y;

    // デフォルトコンストラクタ (原点(0, 0)で初期化)
    Point() {
        x = 0;
        y = 0;
    }

    // 座標を移動させるメンバ関数
    void move(int dx, int dy) {
        x += dx;
        y += dy;
    }

    // 原点からの距離の2乗を返すメンバ関数
    // (平方根はコストが高いため、距離の2乗で比較することが多い)
    int distance_sq_from_origin() {
        // 8bit * 8bit の乗算結果を扱う
        int x_sq_low = x * x;
        int x_sq_high = x ** x;
        int y_sq_low = y * y;
        int y_sq_high = y ** y;

        // 16bitの加算は8bit CPUでは複雑になるため、
        // ここでは単純化して下位8bitのみを足し合わせる
        return x_sq_low + y_sq_low;
    }
};

// --- struct の使用例 ---
int main() {
    // デフォルトコンストラクタが呼ばれ、p1は(0, 0)で初期化される
    struct Point p1;

    // メンバは public なので直接アクセス可能
    p1.x = 10;
    p1.y = 20;

    // メンバ関数を呼び出す
    p1.move(-5, 10); // p1 は (5, 30) になる

    int dist_sq = p1.distance_sq_from_origin();

    return 0;
}
```

#### 3.5. クラス (class) - カプセル化のための型

`class` は、データ（メンバ変数）と、そのデータを操作するための一連の手続き（メンバ関数）を一つにまとめたものです。これにより、プログラムの関心事を分離し、コードの再利用性と保守性を高めます。

##### 3.5.1. なぜ `struct` だけでなく `class` が必要なのか
`struct` は主にデータの集約に用いられます。`struct Player { int hp; };` のように定義すると、どこからでも `player.hp = 999;` のように値を直接書き換えることができ、意図しない変更を招く可能性があります。

`class` は**カプセル化**を強制する仕組みを提供し、データの整合性を保ちやすくします。`class` を使うことで、データの変更を特定のメンバ関数（インターフェース）経由に限定できます。

##### 3.5.2. アクセス指定子 `public`/`private`
`class` のメンバは、`public` と `private` の2つのアクセスレベルを持ちます。

*   **`public` (公開):**
    クラスの外部からアクセス可能なメンバ。クラスの「インターフェース」(API)を構成します。

*   **`private` (非公開):**
    そのクラスのメンバ関数からのみアクセス可能なメンバ。クラスの内部状態や実装の詳細を隠蔽するために使います。`private` メンバへの外部からの直接アクセスは**コンパイルエラー**になります。

*   **デフォルトのアクセスレベル:**
    `public`/`private` キーワードで指定されなかったメンバは、Z++の `class` では**デフォルトで `private`** になります。これは**カプセル化を基本とする**設計思想の表れです。

##### 3.5.3. メンバ関数の定義
*   **クラス内定義:** 簡単な関数は、`class` の定義ブロック `{}` 内に直接実装を記述できます。
*   **クラス外定義:** 関数の実装が長くなる場合は、クラス内で宣言のみを行い、実装をクラス外に記述できます。その際、**スコープ解決演算子 `::`** を用いて、どのクラスに属する関数かを明示します。

##### 3.5.4. コンストラクタ (Constructor)
インスタンスが生成される際に**自動的に呼び出される**特殊なメンバ関数です。

*   **目的:** メンバ変数の初期化を行います。
*   **名前:** クラス名と同じ名前を持ち、戻り値の型はありません。
*   **特徴:** 引数を取ることができ、複数のコンストラクタを定義すること（オーバーロード）も可能です。

##### 3.5.5. 暗黙の引数 `this`
`class` のインスタンス（`player1`, `player2`など）はそれぞれが `hp` などのメンバ変数をRAM上に持ちますが、メンバ関数のコード自体はROM上に一つだけ存在します。

`player1.apply_damage(10)` と `player2.apply_damage(10)` が呼び出されたとき、同じ関数コードがどのインスタンスの `hp` を操作すればよいかを区別するために、**`this`ポインタ**が使われます。

*   **呼び出しのイメージ:**
    ```zpp
    player1.apply_damage(10);
    ```
*   **内部的な動作:**
    コンパイラは、メンバ関数 `apply_damage` を呼び出す際、第1引数として `player1` の**メモリアドレス**を、第2引数として `10` を渡すようにコードを変換します。この暗黙的に渡されるインスタンスのアドレスが `this` の正体です。

*   **アセンブリレベル:**
    Z++の呼び出し規約では、`this`ポインタは**`r1`レジスタ**に格納されます。後続の引数は `r2`, `r3`... と順にレジスタに割り当てられます。

##### 3.5.6. サポートされないC++の機能
Z++の `class` は、8ビットCPUでの効率的な実装を優先するため、以下の高度なC++の機能はサポートしません。
*   **継承**
*   **仮想関数 (Virtual Functions)**
*   **デストラクタ (Destructor)**

これらの機能がないため、`class` は純粋なデータと関数のカプセル化のツールとして機能します。

##### 3.5.7. クラスの使用例
```zpp
// --- タイマークラスの定義 ---
class Timer {
public:
    Timer(); // コンストラクタ
    void set_limit(int new_limit);
    void tick();
    int has_expired();

private:
    int counter;
    int limit;
    int is_expired;
};


// --- メンバ関数の実装 (クラス外定義) ---

// コンストラクタ: メンバ変数を初期化
Timer::Timer() {
    counter = 0;
    limit = 255;
    is_expired = 0;
}

// タイマーの上限値を設定
void Timer::set_limit(int new_limit) {
    limit = new_limit;
}

// カウンタを1進める
void Timer::tick() {
    counter = counter + 1;
    if (counter >= limit) {
        is_expired = 1;
        counter = 0; // カウンタをリセット
    }
}

// タイマーが上限に達したかを確認
int Timer::has_expired() {
    if (is_expired == 1) {
        is_expired = 0; // フラグをリセットして一度だけ通知
        return 1;
    }
    return 0;
}


// --- Z++プログラムのメイン処理 ---

int main() {
    class Timer short_timer; // コンストラクタが呼ばれる
    class Timer long_timer;

    short_timer.set_limit(100);
    long_timer.set_limit(200);

    // 255回ループを実行
    for (int i = 0; i < 255; i++) {
        short_timer.tick();
        long_timer.tick();

        if (short_timer.has_expired()) {
            // 短いタイマーが満了 (例: ポート0のLEDを点灯)
            Output(1, 0);
        }

        if (long_timer.has_expired()) {
            // 長いタイマーが満了 (例: ポート1のLEDを点灯)
            Output(1, 1);
        }
    }

    return 0;
}
```

#### 3.6. 配列 (array)

同じデータ型の要素を、連続したメモリ領域に複数格納するためのデータ構造です。

*   **宣言:** `型名 配列名[要素数];` の形式で宣言します。`要素数` はコンパイル時に確定している必要があります。
    ```zpp
    int scores[10];       // int型の要素を10個持つ配列
    struct Point path[5]; // struct Point型の要素を10個持つ配列
    ```

*   **初期化:** 宣言時に `{}` を使って初期値を指定できます。要素数が省略された場合、初期化子リストの要素数から自動的に決定されます。
    ```zpp
    int pins[4] = {2, 3, 4, 5};
    int data[5] = {10, 20}; // 指定されなかった要素は0で初期化 -> {10, 20, 0, 0, 0}
    ```

*   **要素へのアクセス:** インデックス（添え字）を `[]` 内に指定してアクセスします。インデックスは `0` から始まります。
    ```zpp
    scores[0] = 100;
    int first_score = scores[0];
    ```
    **範囲外アクセス**のチェックは行われないため、プログラマが注意する必要があります。

*   **多次元配列:** 配列の配列として、多次元配列を定義できます。
    ```zpp
    int matrix[3][4]; // 3行4列の2次元配列
    matrix[1][2] = 1; // 2行目3列目の要素にアクセス
    ```

*   **`sizeof` 演算子:** `sizeof` を配列に適用すると、配列全体のメモリサイズ（バイト単位）が返されます。
    ```zpp
    int scores[10];
    int total_size = sizeof(scores); // 10 が返る (sizeof(int) * 10)
    ```

*   **関数への引き渡し:** 配列を関数に渡す際は、**先頭要素へのアドレス（ポインタ）**が渡されます。詳細は7.2章を参照してください。
    ```zpp
    void process_data(int arr[]);
    process_data(&scores); // 配列の先頭アドレスを渡す
    ```

### 4章 式と演算子 (Expressions and Operators)

#### 4.1. 算術演算子
*   `+` (加算), `-` (減算): 8ビットの範囲で計算され、オーバーフローした場合はラップアラウンドします。例: `255 + 2` は `1` になります。
*   `*` (乗算 - 下位): 8ビット同士の乗算結果の**下位8ビット**を返します (CPUの`MUL`命令に対応)。
*   `**` (乗算 - 上位): 8ビット同士の乗算結果の**上位8ビット**を返します (CPUの`MUH`命令に対応)。
*   `/` (除算): 結果の商（整数部）を返します (CPUの`DIV`命令に対応)。
*   `%` (剰余): 結果の余りを返します (CPUの`MOD`命令に対応)。
*   `++` (インクリメント), `--` (デクリメント)
*   `+=`, `-=`, `*=`, `**=`, `/=`, `%=` (複合代入演算子)

**乗算の例:**
```zpp
int a = 10;
int b = 3;
int product_low = a * b; // product_low は 30
int product_high = a ** b // product_high は 0;
int quotient = a / b; // quotient は 3
int remainder = a % b; // remainder は 1
```

#### 4.2. 比較演算子
`==` (等しい), `!=` (等しくない), `<` (小なり), `>` (大なり), `<=` (小なりイコール), `>=` (大なりイコール)

#### 4.3. 論理演算子
*   `&&` (論理AND), `||` (論理OR): **短絡評価**をサポートします。

#### 4.4. ビット単位演算子
`&` (AND), `|` (OR), `^` (XOR), `~` (NOT), `<<` (左シフト), `>>` (右シフト) はすべてCPUの命令に直接対応します。

#### 4.5. アドレス演算子 (`&`)
変数のメモリアドレスを取得します。

#### 4.6. その他の演算子
*   **`.` (メンバアクセス演算子):** `struct` や `class` のインスタンスのメンバにアクセスします。
    ```zpp
    struct Point p;
    p.x = 10; // pのメンバxにアクセス
    ```
*   **`->` (ポインタ経由メンバアクセス演算子):** `struct` や `class` のポインタ経由でメンバにアクセスします。`(*p).x` の糖衣構文です。
*   **`::` (スコープ解決演算子):** `クラス名::メンバ名` のように、クラスに属する静的メンバや、クラス外でメンバ関数を定義する際に使用します。
*   **`sizeof` (サイズ取得演算子):** 型や変数がメモリ上で占めるサイズをバイト単位で返します。
    ```zpp
    int size_of_int = sizeof(int);           // 1 が返る
    int size_of_point = sizeof(struct Point); // 2 が返る (int + int)
    ```

#### 4.7. 添え字演算子
*   **`[]` (配列アクセス演算子):** 配列の要素にアクセスします。

### 5章 演算子の優先順位
演算子が式の中に複数ある場合、どの順序で評価されるかを定めたルールです。優先順位が高いものほど先に評価されます。

1.  **優先順位 1 (最高):** `()`, `[]`, `.`, `->` (左から右へ結合, 関数呼び出し, 配列添字, メンバアクセス)
2.  **優先順位 2:** `++`, `--` (後置) / 左から右
3.  **優先順位 3:** `**` (乗算 - 上位) / 左から右
4.  **優先順位 4:** `++`, `--`, `~`, `&` (アドレス), `sizeof` (単項演算子) / **右から左**
5.  **優先順位 5:** `*`, `/`, `%` (乗除算) / 左から右
6.  **優先順位 6:** `+`, `-` (加減算) / 左から右
7.  **優先順位 7:** `<<`, `>>` (ビットシフト) / 左から右
8.  **優先順位 8:** `<`, `>`, `<=`, `>=` (関係) / 左から右
9.  **優先順位 9:** `==`, `!=` (等価) / 左から右
10. **優先順位 10:** `&` (ビットAND) / 左から右
11. **優先順位 11:** `^` (ビットXOR) / 左から右
12. **優先順位 12:** `|` (ビットOR) / 左から右
13. **優先順位 13:** `&&` (論理AND) / 左から右
14. **優先順位 14:** `||` (論理OR) / 左から右
15. **優先順位 15 (最低):** `=`, `+=`, `-=`, `*=`, `**=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=` (代入演算子) / **右から左**

**スコープ解決演算子 `::` の扱い:**
*   `::` は `class MotorDriver::MotorDriver()` のように使われ、優先順位の概念とは少し異なります。
*   コンパイラは構文解析の段階で、識別子がどのスコープに属するかを解決するために `::` を利用します。

### 6章 文と制御構造 (Statements and Control Structures)

#### 6.1. `if - else if - else` 文
条件に応じて処理を分岐させます。
```zpp
if (temperature > 100) {
    // 危険: ファンを最大でON
} else if (temperature > 60) {
    // 注意: LEDを点滅させる
} else {
    // 正常
}
```

#### 6.2. `while` ループ (`while (condition) { ... }`)
条件式が真である間、ブロック内の処理を繰り返します。

#### 6.3. `do-while` ループ (`do { ... } while (condition);`)
ブロック内の処理を一度実行してから、条件式を評価します。

#### 6.4. `for` ループ (`for (init; cond; post) { ... }`)
初期化、条件式、後処理を指定して、繰り返し処理を記述します。
```zpp
// 0から9まで10回ループ
for (int i = 0; i < 10; i++) {
    // 処理
}
```

#### 6.5. `switch` 文
一つの変数の値に応じて、多方向に分岐します。
*   `break` を省略すると、後続の `case` が**フォールスルー**（続けて実行）されるので注意が必要です。
```zpp
switch (mode) {
    case 0:
        // スタンバイモードの処理
        break;
    case 1:
        // 実行モードの処理
        break;
    default:
        // どのcaseにも一致しない場合の処理
        // (エラー処理など)
        break;
}
```

#### 6.6. `break` 文 (`break;`)
現在のループ (`while`, `do-while`, `for`) や `switch` 文を強制的に抜けます。

#### 6.7. `return` 文 (`return;` または `return expression;`)
現在の関数を終了し、呼び出し元に制御を戻します。`expression` が指定された場合、その評価結果が関数の戻り値となります。`int` を返す関数では `int` 型の値を返す必要があります。

### 7章 関数 (Functions)

#### 7.1. 関数の定義と呼び出し
一連の処理をまとめたもので、名前を付けて再利用できます。
```zpp
// 2つのintを加算して返す関数
int add(int a, int b) {
    return a + b;
}

// 関数の呼び出し
int result = add(10, 20); // result に 30 が代入される
```

##### 7.1.1. デフォルト引数
関数の宣言時に、引数にデフォルト値を指定できます。

*   **宣言:** 引数リストで **`変数名 = デフォルト値`** のように記述します。
    ```zpp
    void set_led(int pin, int brightness = 255);
    ```
*   **呼び出し:** デフォルト値が設定された引数は、呼び出し時に省略できます。
    ```zpp
    set_led(3);       // pin=3, brightness=255 で呼び出される
    set_led(3, 128);  // pin=3, brightness=128 で呼び出される
    ```
*   **制約:** デフォルト引数は、引数リストの**右側**にまとめる必要があります。`void func(int a = 10, int b);` のような宣言はエラーになります。
*   **アセンブリレベルの動作:** コンパイラが、省略された引数を補って関数呼び出しコードを生成します。

#### 7.2. 呼び出し規約 (Calling Convention)
関数を呼び出す側と呼び出される側での、引数や戻り値の受け渡しに関するルールです。

*   **引数の渡し方:**
    *   **値渡し (デフォルト):** `int`, `struct`, `class` などの引数は、**値がコピーされて**渡されます。関数内で引数の値を変更しても、呼び出し元の変数は影響を受けません。
    *   **参照渡し (`&`):** 型名の後に `&` を付けると、その引数は参照渡しになります。渡されるのは値のコピーではなく、変数の**メモリアドレス（8ビット）**です。関数内での変更は、呼び出し元の変数に直接反映されます。
        ```zpp
        // 値渡し: p1のコピーが渡される
        void draw_point(struct Point pt);
        draw_point(p1);

        // 参照渡し: p1のアドレスが渡される
        void move_point(struct Point& pt);
        move_point(p1);
        ```

*   **配列の引き渡し (特殊ケース):**
    *   配列を関数に渡す場合、**常に先頭要素へのアドレスが渡されます**。これは参照渡しと似ていますが、構文が異なります。
    *   関数定義では `int arr[]` のように記述しますが、これは `int* arr` (ポインタ) と等価です。
    *   関数呼び出し時には、配列名の前に `&` を付けてアドレスを明示的に渡す必要があります。
        ```zpp
        void process_scores(int arr[]); // 配列を受け取る関数の宣言

        int my_scores[50];
        process_scores(&my_scores); // 配列の先頭アドレスを渡す
        // process_scores(my_scores); // この構文はサポートされない
        ```

*   **レジスタ割り当て:**
    *   **引数レジスタ:** `int` 型の引数（および参照渡しの `&`）は、以下の順でレジスタに割り当てられます。
        *   第1引数: `r1` (クラスのメンバ関数の場合、`this`ポインタが暗黙的に使用)
        *   第2引数: `r2`
        *   第3引数: `r3`
        *   第4引数: `r4`
    *   **スタック渡し:**
        *   引数が5個以上ある場合や、`int` 以外の大きな型（値渡しの `struct` や `class`）は、**ハードウェアスタックではなく**、呼び出し側が確保したRAM上の領域（スタックフレーム）経由で渡されます。

*   **戻り値の扱い:**
    *   `int` 型の戻り値は、`r15` レジスタに格納されて返されます。
    *   大きな型 (`struct` や `class`) を返す場合、戻り値用の領域のアドレスが引数として渡されます。

*   **レジスタの退避ルール:**
    *   **Caller-Saved (呼び出し側退避):** `r1-r4`, `r15` は、関数を呼び出す側が必要に応じて退避する責任を持ちます。関数内で自由に破壊される可能性があります。
    *   **Callee-Saved (呼び出される側退避):** `r5-r14` は、関数内で使用する場合、その関数が元の値をスタックなどに退避し、関数を抜ける前に復元する責任を持ちます。

### 8章 組み込み機能 (Built-in Features)

#### 8.1. ストリーム形式I/O (`cout`, `cin`)

*   **`cout(port) << value1 << value2 << ... << end;`**
    指定したポートに、複数の値を連続して出力します。
    *   `port` は出力ポート番号を指定する `int` 型の式です。
    *   `<<` 演算子は、`int` 型の値や変数を次々と出力キューに追加します。
    *   最後に `end` を記述するか、文が `;` で終わると、キューの内容が実際のポートに出力されます。

*   **`cin(port) >> var1 >> var2 >> ... >> end;`**
    指定したポートから、複数の値を連続して入力し、変数に格納します。
    *   `port` は入力ポート番号を指定する `int` 型の式です。
    *   `>>` 演算子は、ポートから読み取った値を**参照渡し**で指定された変数に格納します。
    *   最後に `end` を記述するか、文が `;` で終わると、実際のポート読み込みが実行されます。

**使用例:**
```zpp
int sensor_val;
const int LED_PORT = 3;

// ポート2から値を1つ読み込み、sensor_valに格納
cin(2) >> sensor_val >> end;

// LED_PORT(ポート3)に sensor_val の値と 255 を連続して出力
cout(LED_PORT) << sensor_val << 255 << end;
```

#### 8.2. インラインアセンブリ
*   **`Run.Asm("アセンブリ命令");`**: 文字列として1行のアセンブリコードを埋め込みます。
*   **`Run.AsmBlock { ... }`**: ブロック内に複数行のアセンブリコードを直接記述します。
*   **注意:** Z++の変数やレジスタ割り当てを破壊しないよう、CPUの仕様を熟知した上で使用する必要があります。

#### 8.3. デバッグ出力 (`Run.Debug`)

`Run.Debug` は、プログラムの実行を妨げることなく、開発中のデバッグ情報をホストPC（IDE）に送信するための特殊な機能です。

*   **書式:**
    `Run.Debug("フォーマット文字列", expression1, expression2, ...);`

*   **動作の仕組み:**
    この機能は、Z++コンパイラと**連携するIDE**によって実現されることを前提としています。

    *   **コンパイル時 (`.zpp` -> `.asm`):**
        Z++コンパイラは、`Run.Debug` 文を**何のアセンブリコードにも変換せず、完全に無視**します。これにより、製品版のコードサイズや実行速度に一切影響を与えません。

    *   **デバッグ実行時 (IDEの役割):**
        Z++プログラムをデバッグ実行する際、IDEはソースコードを解析し、`Run.Debug` 文が記述された行に到達すると、`expression` の部分を評価し、その値をフォーマット文字列の `{}` に埋め込んで、IDEのデバッグコンソールに表示します。

*   **重要な注意点:**
    *   この機能は**デバッグビルド時にのみ有効**であり、実際のデバイスで実行されるバイナリには含まれません。
    *   `expression` 部分に**副作用のある式 (`i++`など)**を記述しても、実行時には無視されるため、プログラムのロジックに影響を与えるべきではありません。

*   **使用例:**
    ```zpp
    struct Point p;
    p.x = 50;
    p.y = 100;

    // IDEのデバッグコンソールに "Player position: (50, 100)" と表示される
    Run.Debug("Player position: ({}, {})", p.x, p.y);

    // IDEのデバッグコンソールに "Initialization complete." と表示される
    Run.Debug("Initialization complete.");
    ```

### 第9章 名前空間とモジュール (Namespaces and Modules)

Z++は、コードの再利用性を高め、大規模なプロジェクトを整理して管理するために、C++に似た、しかしZ++の環境に合わせて最適化された、強力なモジュールシステムを提供します。このシステムは、**プリプロセッサ命令**、**名前空間 (`namespace`)**、そして**シンボルのインポート (`using`)** という3つの主要な概念に基づいています。

#### 9.1. Z++におけるモジュールの考え方
プログラムが大きくなるにつれて、全てのコードを一つのファイルに記述するのは非効率的になり、名前の衝突（同じ名前の関数を定義してしまうなど）のリスクも増大します。

Z++のモジュールシステムは、この問題を解決します。
1.  関連する機能（関数、クラス、定数など）を、`math.zpp`や`io.zpp`のような、意味のある単位の**ファイル（モジュール）**に分割します。
2.  **`namespace`** を使って、モジュール内の機能をさらに論理的なグループに分け、名前の衝突を防ぎます。
3.  メインのプログラムファイルから、**`#include`** と **`using`** を使って、必要な機能だけを安全にインポートして利用します。

#### 9.2. プリプロセッサ命令
プリプロセッサ命令は、コンパイラが本格的なコード解析を始める前に実行される、テキストベースの処理です。`#`で始まります。

##### 9.2.1. インクルードガード (`#ifndef`, `#define`, `#endif`)
`#include`が単純なテキスト展開であるため、同じファイルが複数回インクルードされると、同じ関数やクラスが二重に定義されてしまい、コンパイルエラーとなります。これを防ぐため、再利用を目的としたファイル（ヘッダファイルのように使われるファイル）は、**必ずインクルードガードで囲まなければなりません。**

```zpp
// my_module.zpp
#ifndef MY_MODULE_ZPP  // もし 'MY_MODULE_ZPP' というシンボルが未定義なら...
#define MY_MODULE_ZPP  // ...'MY_MODULE_ZPP' を定義済みにする

// --- ここにモジュールの内容を記述 ---
namespace MyModule {
    // ...
}

#endif // MY_MODULE_ZPP の終わり
```
これにより、このファイルがプログラム全体で何回`#include`されても、その内容は最初の1回しかコンパイル対象になりません。

##### 9.2.2. ファイルのインクルード (`#include`)
指定されたファイルの内容を、その場にテキストとして挿入します。
*   **書式:** `#include "ファイルパス"`
*   **動作:** コンパイラは、この行を指定されたファイルの内容全体で置き換えます。

#### 9.3. 名前空間 (`namespace`) による論理的なグループ化
`namespace`は、プログラム内の識別子（関数、クラス、変数など）が所属する「空間」や「領域」を定義します。これにより、異なる名前空間にさえあれば、同じ名前の識別子が共存できます。

*   **定義:** `namespace 名前 { ... }` のブロックで、シンボルをグループ化します。
    ```zpp
    // my_utils.zpp
    namespace Math {
        int add(int a, int b) { return a + b; }
    }
    namespace String {
        // ...
    }
    ```

#### 9.4. 名前空間内のシンボルへのアクセス
`#include`したファイル内の、`namespace`に属するシンボルを利用するには、以下のいずれかの方法を使います。

##### 9.4.1. スコープ解決演算子 (`::`)
`名前空間::シンボル名` の形式で、どの名前空間に属するシンボルかを明示的に指定します。これは最も安全で明確な方法です。

```zpp
#include "my_utils.zpp"

int main() {
    // 'Math'名前空間の'add'関数を、フルネームで呼び出す
    int result = Math::add(10, 20);
    return result;
}
```

##### 9.4.2. `using namespace` 宣言によるインポート
毎回`Namespace::`と書く手間を省くために、特定の名前空間のシンボルを現在のスコープに「持ち込む」ことができます。

*   **特定のシンボルのみをインポート:**
    `using namespace 名前空間::シンボル名;`
    ```zpp
    #include "my_utils.zpp"
    using namespace Math::add; // Math名前空間のaddだけを使えるようにする

    int main() {
        int result = add(5, 3); // 'Math::'が不要になる
        return result;
    }
    ```
*   **名前空間の全シンボルをインポート:**
    `using namespace 名前空間;`
    ```zpp
    #include "my_utils.zpp"
    using namespace Math; // Math名前空間の全てを使えるようにする

    int main() {
        int result = add(5, 3);
        return result;
    }
    ```

#### 9.5. モジュール内のアクセス制御：無名名前空間
Z++では、`public`/`private`キーワードは`class`/`struct`のメンバに対してのみ使用します。ファイルスコープでのグローバルなシンボルの可視性を制御するには、**無名名前空間 (Anonymous Namespace)** を使用します。

*   **目的:** モジュール内部でのみ使用する、外部に公開したくないヘルパー関数やグローバル変数を定義するために使います。
*   **構文:** `namespace { ... }` のように、名前を指定せずに名前空間を定義します。
*   **動作:** 無名名前空間の中で定義されたシンボルは、**そのファイルの外側からは完全にアクセス不可能**になります。これは、C言語の`static`グローバル変数/関数と似た、強力な情報隠蔽の仕組みです。

#### 9.6. 総合的な使用例

**`my_library.zpp` (ライブラリファイル):**
```zpp
#ifndef MY_LIBRARY_ZPP
#define MY_LIBRARY_ZPP

// --- 非公開な内部実装 ---
namespace {
    // この変数は、my_library.zpp の中からしかアクセスできない
    int internal_state = 0;

    // この関数も、my_library.zpp の中からしか呼び出せない
    void update_state() {
        internal_state++;
    }
}

// --- 公開インターフェース ---
namespace MyLib {
    // この関数は、他のファイルから MyLib::run() として呼び出せる
    void run() {
        update_state(); // 内部の非公開関数を呼び出す
    }

    // この定数も、MyLib::VERSION として外部から参照できる
    const int VERSION = 1;
}

#endif
```

**`main.zpp` (アプリケーションファイル):**
```zpp
#include "my_library.zpp"

// MyLib名前空間の'run'関数と'VERSION'定数をインポートする
using namespace MyLib::run;
using namespace MyLib::VERSION;

int main() {
    // OK: 'run'はインポートされている
    run();

    // OK: 'VERSION'もインポートされている
    if (VERSION == 1) {
        // ...
    }

    // コンパイルエラー！
    // 'internal_state'は無名名前空間の中にあるため、
    // このファイルからは存在すら認識できない。
    int state = internal_state;

    return 0;
}
```