### **Z++言語 コンパイラ開発指示書**

#### **1. プロジェクト概要**

あなたは、私が設計したカスタムプログラミング言語「Z++」と、そのターゲットである「8ビット・ロードストアアーキテクチャCPU」のための、ウェブベースの統合開発環境（IDE）を開発するエキスパートです。

提供される仕様書（`ZPPSPECS.md`, `CPUSPECS.md`）を完全に理解し、以下の要件に従って、モダンでインタラクティブなオンラインIDEを構築してください。

**成果物:**
指定されたファイル構成（`Compiler/`フォルダ以下）に沿った、HTML, CSS, JavaScriptの完全なソースコード。

**主要技術スタック:**
*   **HTML5**
*   **TailwindCSS:** VSC風のモダンなUIデザインのため。
*   **JavaScript (ES6+)**
*   **CodeMirror 6:** 高機能エディタ（シンタックスハイライト、コード補完、リンティング等）のため。
*   **GSAP:** スムーズなUIアニメーションのため。
*   **Heroicons:** UIのアイコンのため。
*   **Alpine.js:** タブ切り替えなどのUIインタラクションのため。

---

#### **2. デザイン＆UI/UX仕様**

全体として、Visual Studio Code (VSC) のような、ダークテーマをデフォルトとしたモダンなデザインを採用してください。UIはレスポンシブ対応とし、PCとスマートフォンで最適なレイアウトを提供します。

**ファイル構成:**
```
Compiler/
| - index.html         // アプリケーションの骨格
| - style.css          // TailwindCSSの出力とカスタムスタイル
| - main.js            // 全体を統括する司令塔
| - editor.js          // CodeMirror 6の設定とZ++言語サポート
| - lexer.js           // 字句解析器
| - parser.js          // 構文解析器
| - analyzer.js        // 意味解析器
` - generator.js       // コード生成器
```

**PC版レイアウト:**
*   **ヘッダー:** アプリケーションタイトルと、右側に「コンパイル」ボタン、「設定」アイコンボタン（歯車アイコン）を配置。
*   **メインエリア（2カラム）:**
    *   **左パネル (70%):** Z++コードエディタ (`CodeMirror 6`)。
    *   **右パネル (30%):** コンパイル後に生成されたアセンブリコードを表示する読み取り専用エリア。
*   **フッターエリア（パネル）:**
    *   **タブ:** 「コンソール」「問題」の2つのタブ。クリックで表示内容を切り替える。
    *   **パネル内容:**
        *   **コンソール:** コンパイル結果（成功メッセージやエラーリスト）を表示。
        *   **問題:** エディタでのリアルタイム構文チェックで検出された問題をリスト表示。

**スマートフォン版レイアウト:**
*   **ヘッダー:**
    *   左側にファイル名 (`main.zpp`) を表示。
    *   右側に「**コンパイル実行**」アイコンボタン（緑色の再生ボタン風）と「**設定**」アイコンボタン（歯車アイコン）を配置。
*   **メインエリア:**
    *   フッターのタブ選択に応じて、このエリアの表示内容が切り替わります。
        *   `Code`タブ選択時: Z++コードエディタを画面全体に表示。
        *   `Asm`タブ選択時: コンパイル後のアセンブリコードを読み取り専用で表示。
        *   `Problems`タブ選択時: リアルタイム構文エラーのリストを表示。
        *   `Console`タブ選択時: コンパイル結果のメッセージリストを表示。
*   **フッター (タブバー):**
    *   画面下部に固定のタブバーを設置。
    *   以下の4つのアイコン付きタブを配置: **`Code`**, **`Asm`**, **`Problems`**, **`Console`**。
    *   現在選択されているタブは視覚的にハイライトすること。

---

#### **3. 機能仕様**

**3.1. エディタ機能 (`editor.js` & CodeMirror 6)**

*   **シンタックスハイライト:** `ZPPSPECS.md`に基づき、以下の要素を色分けすること。
    *   **キーワード (`int`, `void`, `const`, `return`, `Output`, `Input`, `Run`):** 紫色
    *   **コメント (`//`, `/* */`):** 緑色
    *   **数値リテラル (`123`, `0xFF`, `0b1010`):** 明るい緑色
    *   **文字列 (インラインアセンブラ内):** オレンジ色
    *   **関数名:** 黄色
    *   **演算子 (`+`, `-`, `++`, `--`):** 白色
*   **リアルタイム構文チェック (Linter):**
    *   `parser.js`を利用し、入力中に構文エラーを検知してエディタ内に赤い波線を表示する。
    *   検出したエラー（内容、行、列）は、即座に「問題」タブ/ビューにリストアップする。
*   **エラー箇所へのジャンプ:**
    *   「コンソール」または「問題」タブ/ビューのエラー項目クリックで、エディタの該当箇所にジャンプし、行をハイライトする。
*   **コード補完 (予測変換):**
    *   `@codemirror/autocomplete`を利用して実装する。補完候補として以下を動的に提示すること。
        *   Z++のキーワード (`int`, `const`, `return` など)
        *   定義済みのグローバル変数名および定数名
        *   定義済みの関数名
        *   独自機能 (`Output`, `Input`, `Run.Asm`, `Run.AsmBlock`)
*   **追加機能:**
    *   **コード折りたたみ:** `{}`ブロックや複数行コメントを折りたたむ機能。
    *   **インデントガイド:** インデントの深さを示す縦線を視覚的に表示。
    *   **括弧のマッチング:** 対応する`()`や`{}`をハイライト表示。
    *   **ホバーツールチップ:** 変数や関数名にカーソルを合わせると、その型情報（例: `(global) const int LED_PIN` や `(function) void setup()`）をツールチップで表示する。

**3.2. コンパイル処理 (`main.js`が起点)**

1.  **トリガー:** ヘッダーの「コンパイル」ボタンがクリックされる。
2.  **実行:** `main.js`がエディタからコードを取得し、`lexer` -> `parser` -> `analyzer` -> `generator`の順でコンパイル処理を呼び出す。
3.  **早期中止:** いずれかのフェーズでエラーが1つでも発生した場合、コンパイル処理は即座に中止する。
4.  **結果表示:**
    *   **成功時:**
        *   生成されたアセンブリコードを右パネル（PC）または`Asm`ビュー（スマホ）に表示する。
        *   「コンソール」タブ/ビューに「コンパイルが正常に完了しました。」のような成功メッセージを表示する。
    *   **失敗時:**
        *   発生したエラー（エラーメッセージ、行番号、列番号）を「コンソール」タブ/ビューにリスト形式で表示する。
        *   各エラー項目はクリック可能で、クリックするとエディタの該当箇所にジャンプする。

**3.3. 設定機能**

1.  **トリガー:** ヘッダーの「設定」アイコンボタンがクリックされる。
2.  **動作:** 以下の設定項目を含むモーダルウィンドウをGSAPで滑らかに表示する。設定は`localStorage`に保存し、次回起動時も維持されるようにする。
3.  **設定項目:**
    *   **エディタ設定:**
        *   **テーマ:** `ライト` / `ダーク` (トグルスイッチ)
        *   **フォントファミリー:** `Fira Code`, `Source Code Pro`, `Monospace` (ドロップダウン)
        *   **フォントサイズ:** `+` / `-` ボタン
        *   **タブサイズ:** `2` / `4` (ドロップダウン)
        *   **コード補完:** `オン` / `オフ` (トグルスイッチ)
    *   **コンパイラ設定:**
        *   **ソースマップコメント:** `オン` / `オフ` (トグルスイッチ)。オンの場合、生成されるアセンブリコードに、対応する元のZ++コード行をコメントとして含める。

---

#### **4. Z++言語 実装範囲の限定**

以下の機能に限定してコンパイラを実装してください。

| 機能分類 | 実装する機能 |
| :--- | :--- |
| **基本構造** | 第1部、第2部の全機能（コメント、識別子、キーワード、リテラル） |
| **データ型** | `int` (8bit符号なし), `void` |
| **変数/定数** | **グローバル変数のみ** (`int x;`, `int y = 10;`), `const int NAME = value;` |
| **演算子** | `+`, `-`, `++` (後置), `--` (後置), `+=`, `-=` |
| **制御構造** | `return expression;` |
| **関数** | **引数なし**の`int`/`void`型関数の定義と呼び出し |
| **独自機能** | `Output(value, port);`, `Input(variable, port);`, `Run.Asm("...");`, `Run.AsmBlock{...}` |

---

#### **5. コンパイラ各モジュールの実装方針**

**5.1. `lexer.js` (字句解析器)**
*   上記「実装する機能」に必要なトークン（例: `INT`, `VOID`, `IDENTIFIER`, `NUMBER`, `PLUS`, `MINUS`, `RETURN`など）を認識し、トークンのストリームを生成する。

**5.2. `parser.js` (構文解析器)**
*   `lexer`からのトークンストリームを元に、再帰下降パーサを実装し、AST（Abstract Syntax Tree）を構築する。
*   **ASTノード例:** `Program`, `VariableDeclaration`, `FunctionDeclaration`, `ReturnStatement`, `CallExpression`, `BinaryExpression`, `UpdateExpression`, `OutputStatement`, `InputStatement`, `AsmStatement`

**5.3. `analyzer.js` (意味解析器)**
*   `parser`が生成したASTを受け取り、意味的な正しさを検証する。
*   **シンボルテーブル:** 単一のグローバルスコープを持つシンボルテーブルを使用し、変数名、定数名、関数名を管理する。
    *   変数: `{ type: 'int', address: 0x01 }`
    *   定数: `{ type: 'const int', value: 100 }`
    *   関数: `{ type: 'function', returnType: 'int' }`
*   **チェック項目:**
    1.  変数/関数/定数の二重定義
    2.  未定義のシンボルの使用
    3.  `const`定数への再代入
    4.  プログラムのエントリーポイントである`main`関数の存在確認
*   **アドレス割り当て:** グローバル変数にRAMの`0x00`から順にアドレスを割り当てる。

**5.4. `generator.js` (コード生成器)**
*   意味解析済みのASTから、ターゲットCPUのアセンブリコードを生成する。
*   **規約:**
    *   汎用スタックポインタとしてアドレスポインタ **`ap14`** を使用する。これは関数呼び出し時のレジスタ退避/復帰に**必須**である。
    *   式評価など一時的な計算には、Caller-Savedレジスタ (`r1`〜`r4`) を優先的に使用する。
*   **生成コード詳細:**
    *   **`_start`セクション (必須):** プログラムの冒頭に以下の定型コードを生成する。
        ```assembly
        ; System Initialization
        MCL              ; Clear all RAM
        RCL              ; Clear all Registers
        API  ap14, 255   ; Initialize Stack Pointer to the end of RAM
        
        ; Initialize Global Variables (if any)
        ; (ここにグローバル変数の初期化コードが入る)

        ; Entry Point
        CAL  main        ; Call the main function
        HLT              ; Halt the CPU when main returns
        ```
    *   **グローバル変数初期化:** `int x = 10;` の場合、`_start`内で `LDI r1, 10` と `MST r1, ap0, [xのアドレス]` を生成。
    *   **関数:**
        *   **プロローグ:** 関数内で使用するCallee-Savedレジスタ (`r5`〜`r14`) を`PSH`命令で退避する。
        *   **エピローグ:** 関数の末尾で、退避したレジスタを`POP`命令で復帰させ、`RET`命令を生成する。
    *   **`return`文:** `expression`を評価した結果を`r1`に格納し、`MOV r1, r15`で戻り値レジスタにコピーした後、エピローグにジャンプする。
    *   **式 (`a + b`):** `a`の値を`r1`に、`b`の値を`r2`にロードし、`ADD r1, r2, r1` を実行。
    *   **`Output(value, port)`:**
        1.  `value`を評価し、結果を`r1`に格納。
        2.  `port`を評価し、結果を`r2`に格納。
        3.  `APD r2, r0, ap1` でポートアドレスを`ap1`に設定 (**CPU仕様準拠**)。
        4.  `PST r1, ap1, 0` で出力。
    *   **`Input(variable, port)`:**
        1.  `variable`のメモリアドレスを`r1`にロード。
        2.  `port`を評価し、結果を`r2`に格納。
        3.  `APD r1, r0, ap1` でメモリアドレスを`ap1`に設定。
        4.  `APD r2, r0, ap2` でポートアドレスを`ap2`に設定。
        5.  `PLD r3, ap2, 0` でポートから入力。
        6.  `MST r3, ap1, 0` で変数に格納。
    *   **インラインアセンブラ:** `Run.Asm`と`Run.AsmBlock`の内容をそのままコードに埋め込む。
